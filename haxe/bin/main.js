// Generated by Haxe 4.3.2
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class MainNode {
	constructor() {
		let t = "";
		let _g = 0;
		let _g1 = 0;
		while(_g < _g1) {
			let i = _g++;
			t += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t + logger_Colors.BLUE + "♥ " + logger_Colors.GREEN + "Start RawEvent project" + logger_Colors.RESET));
		process.stdout.write("\n");
		this.init();
		let t1 = "";
		let _g2 = 0;
		let _g3 = 0;
		while(_g2 < _g3) {
			let i = _g2++;
			t1 += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t1 + logger_Colors.BLUE + "♥ " + logger_Colors.GREEN + "End RawEvent project" + logger_Colors.RESET));
		process.stdout.write("\n");
	}
	init() {
		let path = "data/attendees_00176.json";
		this.initFolders();
		this.testQRCodeGeneration();
		this.generateQR4Attendees(path);
		this.convertPNG2JSONScribis();
		this.convertFakeDatabase(path);
		this.convertFakeLogin(path);
	}
	convertFakeLogin(path) {
		let t = "";
		let _g = 0;
		let _g1 = 0;
		while(_g < _g1) {
			let i = _g++;
			t += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t + logger_Colors.BLUE + "→ " + logger_Colors.WHITE + "convertFakeLogin" + logger_Colors.RESET));
		process.stdout.write("\n");
		let content = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
		let json = { fakelogin : { }};
		let attendeesArr = JSON.parse(content).attendees;
		let _g2 = 0;
		let _g3 = attendeesArr.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let _attendees = attendeesArr[i];
			let obj = Reflect.field(json,"fakelogin");
			let hash = haxe_crypto_Sha256.encode("" + _attendees.userName + "1234");
			let token = haxe_crypto_Sha256.encode("" + _attendees.firstName + "1234");
			_attendees["token"] = token;
			obj["" + hash] = _attendees;
		}
		let tab = 1;
		if(tab == null) {
			tab = 0;
		}
		let t1 = "";
		let _g4 = 0;
		let _g5 = tab;
		while(_g4 < _g5) {
			let i = _g4++;
			t1 += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t1 + logger_Colors.BLUE + "→ " + logger_Colors.WHITE + "write json" + logger_Colors.RESET));
		process.stdout.write("\n");
		js_node_Fs.writeFileSync("" + const_Folder.EXPORT + "/fake_login.json",JSON.stringify(json,null,"\t"));
	}
	convertFakeDatabase(path) {
		let t = "";
		let _g = 0;
		let _g1 = 0;
		while(_g < _g1) {
			let i = _g++;
			t += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t + logger_Colors.BLUE + "→ " + logger_Colors.WHITE + "convertFakeDatabase" + logger_Colors.RESET));
		process.stdout.write("\n");
		let content = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
		let json = { fakedatabase : { }};
		let attendeesArr = JSON.parse(content).attendees;
		let _g2 = 0;
		let _g3 = attendeesArr.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let _attendees = attendeesArr[i];
			let obj = Reflect.field(json,"fakedatabase");
			obj["" + _attendees._id] = _attendees;
		}
		let tab = 1;
		if(tab == null) {
			tab = 0;
		}
		let t1 = "";
		let _g4 = 0;
		let _g5 = tab;
		while(_g4 < _g5) {
			let i = _g4++;
			t1 += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t1 + logger_Colors.BLUE + "→ " + logger_Colors.WHITE + "write json" + logger_Colors.RESET));
		process.stdout.write("\n");
		js_node_Fs.writeFileSync("" + const_Folder.EXPORT + "/fake_database.json",JSON.stringify(json,null,"\t"));
	}
	initFolders() {
		const_Folder.ROOT_FOLDER = process.cwd();
		const_Folder.BIN = haxe_io_Path.join([process.cwd(),"bin"]);
		const_Folder.DIST = haxe_io_Path.join([process.cwd(),"dist"]);
		const_Folder.ASSETS = haxe_io_Path.join([process.cwd(),"assets"]);
		const_Folder.EXPORT = haxe_io_Path.join([process.cwd(),"export"]);
		let v = "Folder.ROOT_FOLDER: " + const_Folder.ROOT_FOLDER;
		let tab = 1;
		if(tab == null) {
			tab = 0;
		}
		let t = "";
		let _g = 0;
		let _g1 = tab;
		while(_g < _g1) {
			let i = _g++;
			t += logger_Logger.TAB;
		}
		let v1 = "" + t + logger_Colors.BLUE + "♥ " + logger_Colors.GREEN + Std.string(v) + logger_Colors.RESET;
		process.stdout.write(Std.string(v1));
		process.stdout.write("\n");
		let v2 = "Folder.ASSETS: " + const_Folder.ASSETS;
		let tab1 = 1;
		if(tab1 == null) {
			tab1 = 0;
		}
		let t1 = "";
		let _g2 = 0;
		let _g3 = tab1;
		while(_g2 < _g3) {
			let i = _g2++;
			t1 += logger_Logger.TAB;
		}
		let v3 = "" + t1 + logger_Colors.BLUE + "♥ " + logger_Colors.GREEN + Std.string(v2) + logger_Colors.RESET;
		process.stdout.write(Std.string(v3));
		process.stdout.write("\n");
		let v4 = "Folder.EXPORT: " + const_Folder.EXPORT;
		let tab2 = 1;
		if(tab2 == null) {
			tab2 = 0;
		}
		let t2 = "";
		let _g4 = 0;
		let _g5 = tab2;
		while(_g4 < _g5) {
			let i = _g4++;
			t2 += logger_Logger.TAB;
		}
		let v5 = "" + t2 + logger_Colors.BLUE + "♥ " + logger_Colors.GREEN + Std.string(v4) + logger_Colors.RESET;
		process.stdout.write(Std.string(v5));
		process.stdout.write("\n");
		sys_FileSystem.createDirectory(const_Folder.EXPORT);
		sys_FileSystem.createDirectory(const_Folder.EXPORT + "/qr");
		sys_FileSystem.createDirectory(const_Folder.EXPORT + "/tag");
		sys_FileSystem.createDirectory(const_Folder.EXPORT + "/combo");
	}
	generateQR4Attendees(path) {
		let content = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
		let attendeesArr = JSON.parse(content).attendees;
		let _g = 0;
		let _g1 = attendeesArr.length;
		while(_g < _g1) {
			let i = _g++;
			let _attendees = attendeesArr[i];
			this.createQRCodes(_attendees,i);
			this.createTag(_attendees,i);
			this.combineQrAndTag(_attendees,i);
		}
	}
	convertPNG2JSONScribis() {
		let json = { };
		let _w = 78;
		let _h = 108;
		let _bleed = 3;
		json["pages"] = [];
		let directory = "export/combo";
		let _g = 0;
		let _g1 = js_node_Fs.readdirSync(directory);
		while(_g < _g1.length) {
			let file = _g1[_g];
			++_g;
			let path = haxe_io_Path.join([directory,file]);
			if(!sys_FileSystem.isDirectory(path)) {
				if(path.indexOf(".png") != -1) {
					let arr = Reflect.field(json,"pages");
					let pageObj = { left : { }, right : { _alias : "test", images : [{ path : "" + path, x : { "unit" : "mm", "value" : -_bleed}, y : { "unit" : "mm", "value" : -_bleed}, width : { "unit" : "mm", "value" : 2 * _bleed + _w}, height : { "unit" : "mm", "value" : 2 * _bleed + _h}}]}};
					arr.push(pageObj);
				}
			}
		}
		let tab = 1;
		if(tab == null) {
			tab = 0;
		}
		let t = "";
		let _g2 = 0;
		let _g3 = tab;
		while(_g2 < _g3) {
			let i = _g2++;
			t += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t + logger_Colors.BLUE + "→ " + logger_Colors.WHITE + "write json" + logger_Colors.RESET));
		process.stdout.write("\n");
		js_node_Fs.writeFileSync("" + const_Folder.EXPORT + "/export_scribus.json",JSON.stringify(json,null,"\t"));
	}
	combineQrAndTag(attendee,i) {
		let str = "00000";
		let temp = str.length - ("" + i).length;
		let newID = HxOverrides.substr(str,0,temp) + i;
		let tag = js_node_Fs.readFileSync("" + const_Folder.EXPORT + "/tag/" + newID + "_tag_" + attendee.userName + ".svg",{ encoding : "utf8"});
		let qr = js_node_Fs.readFileSync("" + const_Folder.EXPORT + "/qr/" + newID + "_qr_" + attendee.userName + ".svg",{ encoding : "utf8"});
		let qrArr = qr.split("\n");
		let rects = "";
		let _g = 0;
		let _g1 = qrArr.length;
		while(_g < _g1) {
			let i = _g++;
			let line = qrArr[i];
			if(line.indexOf("<rect") != -1) {
				rects += line + "\n";
			}
		}
		let combo = tag;
		combo = StringTools.replace(combo,"</svg>","<g id=\"qrcode\" transform=\"matrix(0.26682031,0,0,0.26682031,4.847,35.24044)\">" + rects + "</g></svg>");
		js_node_Fs.writeFileSync("" + const_Folder.EXPORT + "/combo/" + newID + "_combo_" + attendee.userName + ".svg",combo);
	}
	createTag(attendee,i) {
		let str = "00000";
		let temp = str.length - ("" + i).length;
		let newID = HxOverrides.substr(str,0,temp) + i;
		let svg = js_node_Fs.readFileSync("template/nametag_cleaner_v01.svg",{ encoding : "utf8"});
		svg = StringTools.replace(svg,"$company","" + attendee.company);
		svg = StringTools.replace(svg,"$lastname","" + attendee.lastName);
		svg = StringTools.replace(svg,"$firstname","" + attendee.firstName);
		js_node_Fs.writeFileSync("" + const_Folder.EXPORT + "/tag/" + newID + "_tag_" + attendee.userName + ".svg",svg);
	}
	createQRCodes(attendee,i) {
		let str = "00000";
		let temp = str.length - ("" + i).length;
		let newID = HxOverrides.substr(str,0,temp) + i;
		let svg = new QrcodeSvg({ content : "" + attendee._id, padding : 4, width : 256, height : 256, color : "#000000", background : "none", ecl : "M"}).svg();
		js_node_Fs.writeFileSync("" + const_Folder.EXPORT + "/qr/" + newID + "_qr_" + attendee.userName + ".svg",svg);
	}
	testQRCodeGeneration() {
		let t = "";
		let _g = 0;
		let _g1 = 0;
		while(_g < _g1) {
			let i = _g++;
			t += logger_Logger.TAB;
		}
		process.stdout.write(Std.string("" + t + logger_Colors.BLUE + "→ " + logger_Colors.WHITE + "testQRCodeGeneration" + logger_Colors.RESET));
		process.stdout.write("\n");
		let qrcode = new QrcodeSvg({ content : "Matthijs de gekste!", padding : 4, width : 256, height : 256, color : "#000000", background : "#ffffff", ecl : "M"});
		qrcode.save("test.svg",function(error) {
			if(error != null) {
				throw error;
			}
			$global.console.log("Done!");
		});
	}
	static main() {
		let app = new MainNode();
	}
}
MainNode.__name__ = true;
Math.__name__ = true;
var QrcodeSvg = require("qrcode-svg");
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringTools {
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
	static hex(n,digits) {
		let s = "";
		let hexChars = "0123456789ABCDEF";
		do {
			s = hexChars.charAt(n & 15) + s;
			n >>>= 4;
		} while(n > 0);
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
StringTools.__name__ = true;
class const_Folder {
}
const_Folder.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
}
haxe_Exception.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_crypto_Sha256 {
	constructor() {
	}
	doEncode(m,l) {
		let K = [1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998];
		let HASH = [1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225];
		let W = [];
		W[64] = 0;
		let a;
		let b;
		let c;
		let d;
		let e;
		let f;
		let g;
		let h;
		let T1;
		let T2;
		m[l >> 5] |= 128 << 24 - l % 32;
		m[(l + 64 >> 9 << 4) + 15] = l;
		let i = 0;
		while(i < m.length) {
			a = HASH[0];
			b = HASH[1];
			c = HASH[2];
			d = HASH[3];
			e = HASH[4];
			f = HASH[5];
			g = HASH[6];
			h = HASH[7];
			let _g = 0;
			while(_g < 64) {
				let j = _g++;
				if(j < 16) {
					W[j] = m[j + i];
				} else {
					let x = W[j - 2];
					let x1 = (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
					let y = W[j - 7];
					let lsw = (x1 & 65535) + (y & 65535);
					let msw = (x1 >> 16) + (y >> 16) + (lsw >> 16);
					let x2 = msw << 16 | lsw & 65535;
					let x3 = W[j - 15];
					let y1 = (x3 >>> 7 | x3 << 25) ^ (x3 >>> 18 | x3 << 14) ^ x3 >>> 3;
					let lsw1 = (x2 & 65535) + (y1 & 65535);
					let msw1 = (x2 >> 16) + (y1 >> 16) + (lsw1 >> 16);
					let x4 = msw1 << 16 | lsw1 & 65535;
					let y2 = W[j - 16];
					let lsw2 = (x4 & 65535) + (y2 & 65535);
					let msw2 = (x4 >> 16) + (y2 >> 16) + (lsw2 >> 16);
					W[j] = msw2 << 16 | lsw2 & 65535;
				}
				let y = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
				let lsw = (h & 65535) + (y & 65535);
				let msw = (h >> 16) + (y >> 16) + (lsw >> 16);
				let x = msw << 16 | lsw & 65535;
				let y1 = e & f ^ ~e & g;
				let lsw1 = (x & 65535) + (y1 & 65535);
				let msw1 = (x >> 16) + (y1 >> 16) + (lsw1 >> 16);
				let x1 = msw1 << 16 | lsw1 & 65535;
				let y2 = K[j];
				let lsw2 = (x1 & 65535) + (y2 & 65535);
				let msw2 = (x1 >> 16) + (y2 >> 16) + (lsw2 >> 16);
				let x2 = msw2 << 16 | lsw2 & 65535;
				let y3 = W[j];
				let lsw3 = (x2 & 65535) + (y3 & 65535);
				let msw3 = (x2 >> 16) + (y3 >> 16) + (lsw3 >> 16);
				T1 = msw3 << 16 | lsw3 & 65535;
				let x3 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
				let y4 = a & b ^ a & c ^ b & c;
				let lsw4 = (x3 & 65535) + (y4 & 65535);
				let msw4 = (x3 >> 16) + (y4 >> 16) + (lsw4 >> 16);
				T2 = msw4 << 16 | lsw4 & 65535;
				h = g;
				g = f;
				f = e;
				let lsw5 = (d & 65535) + (T1 & 65535);
				let msw5 = (d >> 16) + (T1 >> 16) + (lsw5 >> 16);
				e = msw5 << 16 | lsw5 & 65535;
				d = c;
				c = b;
				b = a;
				let lsw6 = (T1 & 65535) + (T2 & 65535);
				let msw6 = (T1 >> 16) + (T2 >> 16) + (lsw6 >> 16);
				a = msw6 << 16 | lsw6 & 65535;
			}
			let y = HASH[0];
			let lsw = (a & 65535) + (y & 65535);
			let msw = (a >> 16) + (y >> 16) + (lsw >> 16);
			HASH[0] = msw << 16 | lsw & 65535;
			let y1 = HASH[1];
			let lsw1 = (b & 65535) + (y1 & 65535);
			let msw1 = (b >> 16) + (y1 >> 16) + (lsw1 >> 16);
			HASH[1] = msw1 << 16 | lsw1 & 65535;
			let y2 = HASH[2];
			let lsw2 = (c & 65535) + (y2 & 65535);
			let msw2 = (c >> 16) + (y2 >> 16) + (lsw2 >> 16);
			HASH[2] = msw2 << 16 | lsw2 & 65535;
			let y3 = HASH[3];
			let lsw3 = (d & 65535) + (y3 & 65535);
			let msw3 = (d >> 16) + (y3 >> 16) + (lsw3 >> 16);
			HASH[3] = msw3 << 16 | lsw3 & 65535;
			let y4 = HASH[4];
			let lsw4 = (e & 65535) + (y4 & 65535);
			let msw4 = (e >> 16) + (y4 >> 16) + (lsw4 >> 16);
			HASH[4] = msw4 << 16 | lsw4 & 65535;
			let y5 = HASH[5];
			let lsw5 = (f & 65535) + (y5 & 65535);
			let msw5 = (f >> 16) + (y5 >> 16) + (lsw5 >> 16);
			HASH[5] = msw5 << 16 | lsw5 & 65535;
			let y6 = HASH[6];
			let lsw6 = (g & 65535) + (y6 & 65535);
			let msw6 = (g >> 16) + (y6 >> 16) + (lsw6 >> 16);
			HASH[6] = msw6 << 16 | lsw6 & 65535;
			let y7 = HASH[7];
			let lsw7 = (h & 65535) + (y7 & 65535);
			let msw7 = (h >> 16) + (y7 >> 16) + (lsw7 >> 16);
			HASH[7] = msw7 << 16 | lsw7 & 65535;
			i += 16;
		}
		return HASH;
	}
	hex(a) {
		let str = "";
		let _g = 0;
		while(_g < a.length) {
			let num = a[_g];
			++_g;
			str += StringTools.hex(num,8);
		}
		return str.toLowerCase();
	}
	static encode(s) {
		let sh = new haxe_crypto_Sha256();
		let h = sh.doEncode(haxe_crypto_Sha256.str2blks(s),s.length * 8);
		return sh.hex(h);
	}
	static str2blks(s) {
		let s1 = haxe_io_Bytes.ofString(s);
		let nblk = (s1.length + 8 >> 6) + 1;
		let blks = [];
		let _g = 0;
		let _g1 = nblk * 16;
		while(_g < _g1) {
			let i = _g++;
			blks[i] = 0;
		}
		let _g2 = 0;
		let _g3 = s1.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let p = i >> 2;
			blks[p] |= s1.b[i] << 24 - ((i & 3) << 3);
		}
		let i = s1.length;
		let p = i >> 2;
		blks[p] |= 128 << 24 - ((i & 3) << 3);
		blks[nblk * 16 - 1] = s1.length * 8;
		return blks;
	}
}
haxe_crypto_Sha256.__name__ = true;
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
}
haxe_io_Bytes.__name__ = true;
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
class haxe_io_Path {
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		let _g2 = paths;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		let paths1 = _g;
		if(paths1.length == 0) {
			return "";
		}
		let path = paths1[0];
		let _g3 = 1;
		let _g4 = paths1.length;
		while(_g3 < _g4) {
			let i = _g3++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += paths1[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let tmp = target.join(slash);
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g_offset = 0;
		let _g_s = tmp;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
haxe_io_Path.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_Fs = require("fs");
var js_node_Path = require("path");
class logger_Colors {
}
logger_Colors.__name__ = true;
class logger_Logger {
}
logger_Logger.__name__ = true;
class sys_FileSystem {
	static isDirectory(path) {
		try {
			return js_node_Fs.statSync(path).isDirectory();
		} catch( _g ) {
			return false;
		}
	}
	static createDirectory(path) {
		try {
			js_node_Fs.mkdirSync(path);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "ENOENT") {
				sys_FileSystem.createDirectory(js_node_Path.dirname(path));
				js_node_Fs.mkdirSync(path);
			} else {
				let stat;
				try {
					stat = js_node_Fs.statSync(path);
				} catch( _g ) {
					throw e;
				}
				if(!stat.isDirectory()) {
					throw e;
				}
			}
		}
	}
}
sys_FileSystem.__name__ = true;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
logger_Colors.RESET = "\x1B[0m";
logger_Colors.GREEN = "\x1B[0;32m";
logger_Colors.BLUE = "\x1B[0;34m";
logger_Colors.WHITE = "\x1B[0;37m";
logger_Logger.TAB = "    ";
MainNode.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
